# How to decode online LiDAR

## 1 Introduction

This document illustrates how to decode the MSOP/DIFOP packets from an online Lidar with the driver's API.

## 2 Design Consideration

The driver is designed to achieve these objectives.
+ Parallel the construction and the process of point cloud.
+ Avoid to copy point cloud.
+ Avoid to malloc/free point cloud repeatly.

Below is the supposed interaction between rs_driver and user's code. 

![](./img/11_rs_driver_queue_thread.png)

rs_driver runs in its thread `construct_thread`. It
+ Gets free point cloud from user. User fetches it from a free cloud queue `free_point_cloud_queue`. If the queue is empty, then create a new one.
+ Parses packets and constructs point cloud.
+ Returns stuffed point cloud to user.
+ User's code is supposed to shift it to the queue `stuffed_point_cloud_queue`.

User's code runs in its thread `process_thread`. It
+ Fetches stuffed point cloud from the queue `stuffed_point_cloud_queue`
+ Process the point cloud
+ Return the point cloud back to the queue `free_point_cloud_queue`. rs_driver will use it again.

## 3 Steps

Below is the steps to use the driver's API.

### 3.1 Define Point

Point is the base unit of Point Cloud. The driver supposes that it may have these member variables.
- x -- The x coordinate of point. float type.
- y -- The y coordinate of point. float type.
- z -- The z coordinate of point. float type.
- intensity -- The intensity of point. uint8_t type. 
- timestamp -- The timestamp of point. double type.  It may generated by the Lidar or on the host machine.
- ring -- The ring ID of the point, which represents the row number. e.g. For RS80, the range of ring ID is 0~79 (from bottom to top).

Below are some examples: 

- The point type contains **x, y, z, intensity**

  ```c++
  struct PointXYZI
  {
    float x;
    float y;
    float z;
    uint8_t intensity;
    ...
  };
  ```

- If using PCL, a simple way is to use **pcl::PointXYZI**.

- The point type contains **x, y, z, intensity, timestamp, ring**

  ```c++
  struct PointXYZIRT
  {
    float x;
    float y;
    float z;
    uint8_t intensity;
    double timestamp;
    uint16_t ring;
    ...
  };
  ```

Here user may add new member variables, remove member variables, or change the order of them, but should not change names or types of them, otherwise the behaviors might be unexpected.

### 3.2 Define Point Cloud

  The driver allows user to change the point cloud type, as long as it is compatible to the definition below.

  ```c++
  template <typename T_Point>
  class PointCloudT
  {
  public:
    typedef T_Point PointT;
    typedef std::vector<PointT> VectorT;

    uint32_t height = 0;    ///< Height of point cloud
    uint32_t width = 0;     ///< Width of point cloud
    bool is_dense = false;  ///< If is_dense is true, the point cloud does not contain NAN points
    double timestamp = 0.0; ///< Timestamp of point cloud
    uint32_t seq = 0;       ///< Sequence number of message

    VectorT points;
  };
  
  typedef PointXYZI PointT;
  typedef PointCloudT<PointT> PointCloudMsg;
  ```

  Here user may add new members, and change the order of these members, but should not change or remove them.

### 3.3 Point in Point Cloud

For mechanical Lidar, it may be useful to explain how the layout of point cloud is like. 

Here is an example of mechanical 5_lasers Lidar. 

The Lidar scans block by block. It starts from b0c0(block 0 channel/laser 0), b0c1, b0c2, b0c3, b0c4, and then go to b1c0, b1c1, b1c2, b1c3, b1c4, and so on.
![](./img/11_rs_driver_point_cloud.png)

At the same time, it saves the points in a vector, point by point, as below.
![](./img/11_rs_driver_point_cloud_vector.png)

### 3.4 Define the driver object

Define a driver object.

```c++
int main()
{
  LidarDriver<PointCloudMsg> driver;          ///< Declare the driver object
  ...
}
```

### 3.5 Configure the driver parameter

Define a RSDriverParam variable and configure it.
+ `InputType::ONLINE_LIDAR` means that the driver get packets from a online Lidar.
+ `LidarType::RS16` means a RS16 Lidar.
+ Also set the local MSOP/DIFOP ports. Please use a 3rd party tool, such as WireShark, to get them.

```c++
int main()
{
  ...
  RSDriverParam param;                             ///< Create a parameter object
  param.input_type = InputType::ONLINE_LIDAR;      /// get packet from online lidar
  param.input_param.msop_port = 6699;             ///< Set the lidar msop port number, the default is 6699
  param.input_param.difop_port = 7788;            ///< Set the lidar difop port number, the default is 7788
  param.lidar_type = LidarType::RS16;             ///< Set the lidar type. Make sure this type is correct
  ...
}
```

### 3.6 Define and register Point Cloud callbacks

+ As said above, user is supposed to provide free point cloud to the driver. 

```c++
SyncQueue<std::shared_ptr<PointCloudMsg>> free_cloud_queue;

std::shared_ptr<PointCloudMsg> driverGetPointCloudFromCallerCallback(void)
{
  std::shared_ptr<PointCloudMsg> msg = free_cloud_queue.pop();
  if (msg.get() != NULL)
  {
    return msg;
  }

  return std::make_shared<PointCloudMsg>();
}
```

+ Also user is supposed to accept stuffed point cloud from the driver. 

```c++
SyncQueue<std::shared_ptr<PointCloudMsg>> stuffed_cloud_queue;

void driverReturnPointCloudToCallerCallback(std::shared_ptr<PointCloudMsg> msg)
{
  stuffed_cloud_queue.push(msg);

  RS_MSG << "msg: " << msg->seq << " point cloud size: " << msg->points.size() << RS_REND;
}
```

Note: The driver calls these two callback functions in its `contruct_thread`, so **don't do any time-consuming task** in them. 

+ User process the point cloud in its own thread.

```c++
void processCloud(void)
{
  while (1)
  {
    std::shared_ptr<PointCloudMsg> msg = stuffed_cloud_queue.popWait();
    if (msg.get() == NULL)
    {
      continue;
    }

    // Well, it is time to process the point cloud msg, even it is time-consuming.
    RS_MSG << "msg: " << msg->seq << " point cloud size: " << msg->points.size() << RS_REND;

    free_cloud_queue.push(msg);
  }
}

```

+ Register them to the driver.

```c++
int main()
{
  ...
  driver.regPointCloudCallback(driverReturnPointCloudToCallerCallback, 
                               driverReturnPointCloudToCallerCallback);
  ...
}
```

### 3.7 Define and register exception callbacks

+ When an error happens, the driver will inform user. User is supposed to get it via a callback function. 

```c++
void exceptionCallback(const Error &code)
{
  RS_WARNING << "Error code : " << code.toString() << RS_REND;
}
```

Once again, **don't do any time-consuming task** in it.

+ Register the callback.

```c++
int main()
{
  ...
  driver.regExceptionCallback(exceptionCallback);  ///<Register the exception callback function
  ...
}
```

### 3.8 Initialize the driver

Call the initialization function with the the RSDriverParam object.

```c++
int main()
{
  ...
  if (!driver.init(param))  ///< Call the init function with the parameter
  {
    RS_ERROR << "Driver Initialize Error..." << RS_REND;
    return -1;
  }
  ...
}
```

### 3.9 Start the driver

Start the driver.

```c++
int main()
{
  ...
  driver.start();  ///< Call the start function. The driver thread will start
  ...
}
```

## 4 Congratulation

You have finished the demo tutorial of online LiDAR!

Please find the complete demo code in the project file ```rs_driver/demo/demo_online.cpp```. 

Feel free to contact us if you have any questions.

